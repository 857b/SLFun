Comparison with Steel
=========================================

SLFun is inspired by the [Steel](https://github.com/FStarLang/steel) framework
of [F\*](http://www.fstar-lang.org/).
The main common points are:
- A logic based on separation logic.
- The way programs are defined: the user first defines an annotated program in
  a proof assistant. Those programs are proven correct using tactics and
  extracted (to C in the case of Steel).
- A concept of vprop to separates reasoning about the shape of the memory (using
  fully automated tactics) and its content.

### Vprops

Our definition of vprops is different from the one of Steel.
In our framework, a `SLprop.p` of selector type `t` is a separation logic
predicate `t -> SLprop.t`.
In Steel, a vprop `v` is defined by (in [Steel.Effect.Common.fsti](https://github.com/FStarLang/steel/blob/cef79a491367100147f0fb2a187cea934665c519/lib/steel/Steel.Effect.Common.fsti#L78)):

```fstar
type vprop' =
  { hp: slprop u#1;
    t:Type0;
    sel: selector t hp}
```

That is:

- A separation logic proposition `hp v : slprop`
- A selector function, `sel v` which defines the value of the selector for any
  memory on which `hp v` holds.

Note that the record contains the type `t` of the selector, rather than
being indexed by it. So the equivalent type in our framework is `SLprop.t`
rather than `SLprop.p`.
There is a framing condition on the selector function: it should be unchanged if
the heap is joined with another compatible heap.

The definition used by Steel is more restrictive than our definition.
That is, any vprop whose selector is expressed using a function can be turned
into a predicate. But the converse is not true. In particular, defining the
selector as a function implies that a heap cannot contains a same vprop
multiple times with different selectors.
This condition makes sense since if a same vprop appears multiple time in a
context, then the instance that will be used is chosen implicitly by the tactic
when generating the functional representation. This can lead to the generation
of a functional program that cannot be used to prove the program correct because
of a wrong choice.
However this can only happen if a same (in a syntactic sense) vprop appears
twice in an actual context. The definition used by Steel restricts us to vprops
for which we can define an unique selector on *any* heap that matches the
underlying separation logic proposition.
For instance, one cannot define in Steel a vprop `lseg entry next` like we did
in [Test.SLList](../Test/SLList.v). Indeed, on a heap with a cyclic linked list
containing a cell at address `p`, `lseg p p` can either represent the full cycle
or the empty segment (which have different selectors). This problem can be
solved by adding another argument to the vprop, such as the length of the
segment it represents. But this additional argument must be handled explicitly
as a ghost variable in the program.
By defining vprop as predicates, we are free to choose which arguments we
expose. It is the responsibility of the user to choose enough arguments so that
the contexts that appears in the programs never contain twice a same vprop.

### Verification condition generation

Steel generates directly a verification condition (VC), by induction on the
structure of the program. This VC is then discharged by the Z3 SMT solver.
This VC quantifies over the memories at the different program location.
Since the selectors are defined as functions, they can be extracted from those
memories.
In this encoding, the introduction of a new memory hence introduces possibly new
values for every selector in the context. To encode the fact that the vprops not
affected by an operation (i.e. framed out) are unchanged, Steel must had
equalities between the selectors before and after the operation.

SLFun generates a functional translation of the imperative program.
One can then theoretically use multiple approaches to prove that this functional
representation matches its specification (abstract interpretation, interactive
tactics, VC generation...). For now only a weakest precondition generation is
implemented.

This functional representation is intended to be conciser and easier
to read than the VC generated by Steel.
Moreover the selectors are represented using individual variables rather than
using variables that represent whole memories. As a consequence after an
operation, we can introduce fresh variables only for the selectors affected and
keep using the old variables for the framed-out vprops. This avoids the need for
additional equalities.

One could define an alternative VC generation for Steel using functional
representation. However one could not use the VC generation method of Steel with
our definition of vprops since Steel uses the fact that selectors are defined as
functions to retrieve the selectors from memories.

### Definition of lemmas

In Steel, lemmas can be defined like programs and benefit from the same automation.
One could probably do the same thing for SLFun, but for now lemmas must be
proven in the underlying separation logic, using interactive tactics.

### Features of F\*

Steel programs are defined using the system of effect of F\*. This allows the
use of operations defined in the `PURE` effect. Such operations are associated
to a weakest-precondition which is used by Steel in the generation of the
verification condition. This is useful for partial operations and proving pure
assertions.

The effect system is also used to label ghost code and to ensure that it can be
erased. After erasure, the implementations can be extracted to `C` code using
[KRML](https://github.com/FStarLang/karamel).

### Concurrency

Steel allows reasoning about concurrent programs. For this purpose it provides
several features that are not presents in SLFun:

- ghost memory cells that are joined using user-defined monoids
- invariants
- a notion of atomic code

The first point concerns mostly the underlying separation logic but the two
others are taken into account during the definition of implementations. Steel
uses the effect system effect of F\* to keep track of the set of opened
invariants at each point and has a special effect for atomic code.
